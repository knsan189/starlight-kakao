/* eslint-disable no-console */
import { Router } from "express";
import DiscordApi from "../apis/discord.api.js";
import { format, formatDistanceToNow } from "date-fns";
import ko from "date-fns/locale/ko/index.js";
import LostArkApi from "../apis/lostark.api.js";
import FortuneApi from "../apis/fortune.api.js";

declare global {
  interface String {
    format: (...args: string[]) => string;
  }
}

const prefix = "/";
const MessageRouter = Router();
const tagRegex = /<[^>]*>?/g;

const FortuneMap = new Map<string, Fortune>();
let timestamp = new Date();

function getParsedSender(sender: string) {
  return sender.split("/")[0].trim();
}

String.prototype.format = function (...args: string[]) {
  return this.replace(/{([0-9]+)}/g, function (match, index) {
    return typeof args[index] === "undefined" ? match : args[index];
  });
};

function parseElilxer(text: string) {
  return text
    .replace(tagRegex, "")
    .replace(/\[(.*?)\]/g, "")
    .trim();
}

const MSG_REACTION = ["ÏïàÎÖïÌïòÏÑ∏", "ÏïàÎÖï ÌïòÏÑ∏", "Ï¢ãÏùÄ ÏïÑÏπ®", "Ï¢ãÏùÄÏïÑÏπ®", "ÍµøÎ™®", "Íµ≥Î™®"];
const MSG_COMMAND_LIST = ["/Î™ÖÎ†πÏñ¥", "/ÎèÑÏõÄÎßê", "/?"];

MessageRouter.post("/", async (req, res) => {
  try {
    const { msg, sender }: MessageRequest = req.body;

    console.log(`[${new Date().toLocaleString()}] ${sender} : ${msg}`);

    if (MSG_REACTION.some((item) => msg.includes(item))) {
      const parsedSender = sender.split("/")[0].trim();
      return res.send(`${parsedSender}Îãò ÏïàÎÖïÏïàÎÖïÌïòÏÑ∏Ïöî !`);
    }

    if (msg.includes("ÏäπÌò∏") && msg.includes("Ïñ∏Ï†ú")) {
      const member: DiscordMember = await DiscordApi.getMember("ÏäπÌò∏");

      const { lastJoinedTime, lastLeaveTime } = member;

      if (!lastJoinedTime || !lastLeaveTime) {
        return;
      }

      if (new Date(lastJoinedTime).getTime() > new Date(lastLeaveTime).getTime()) {
        const date = formatDistanceToNow(new Date(lastJoinedTime), {
          addSuffix: true,
          locale: ko,
        });

        return res.send({
          reply: `ÏßÄÍ∏à Ï†ëÏÜçÏ§ëÏù¥Ïã†Í±∏Ïöî ???`,
          secondReply: `${date}Ïóê Ï†ëÏÜçÌïòÏÖîÏÑú ÏïÑÏßÅ Í≥ÑÏã≠ÎãàÎã¥. Îòê Ïñ∏Ï†ú ÏÇ¨ÎùºÏßÄÏã§ÏßÄÎäî Î™®Î•¥Í≤†ÏßÄÎßåÏöî`,
        });
      }

      const date = formatDistanceToNow(new Date(lastLeaveTime), {
        addSuffix: true,
        locale: ko,
      });

      return res.send({ reply: `ÎîîÏΩî ${date}Ïóê ÎßàÏßÄÎßâÏúºÎ°ú Ï†ëÏÜçÌïòÏãúÍµ¨ Îã§Ïãú ÏïàÏò§ÏÖ®Ïñ¥Ïöî „Ö†„Ö†` });
    }

    if (msg.includes("ÎîîÏΩî") && msg.includes("ÎàÑÍµ¨")) {
      const members = await DiscordApi.getMembers();
      const currentUser: DiscordMember[] = [];
      members.forEach((member) => {
        if (member.lastLeaveTime && member.lastJoinedTime) {
          const joinTime = new Date(member.lastJoinedTime).getTime();
          const leaveTime = new Date(member.lastLeaveTime).getTime();
          if (joinTime > leaveTime) {
            currentUser.push(member);
          }
        } else {
          currentUser.push(member);
        }
      });

      if (currentUser.length === 0) {
        return res.send({ reply: `ÏßÄÍ∏à ÏïÑÎ¨¥ÎèÑ Ï†ëÏÜç ÏïàÌïòÍ≥† ÏûàÎäîÍ±∞ Í∞ôÏïÑÏöî ! ÏïÑÎßàÎëêÏöî` });
      }

      let message = "ÏßÄÍ∏à ";
      currentUser.forEach((member) => {
        message += `${getParsedSender(member.nickname)}Îãò `;
      });
      message += "Ï†ëÏÜçÌï¥ Í≥ÑÏãúÎäîÍ±∞ Í∞ôÏïÑÏöî !";
      return res.send({ reply: message });
    }

    if (!msg.startsWith(prefix)) return;
    const args = msg.split(" ");
    const cmd = args.shift()?.slice(prefix.length);
    let parsedSender = getParsedSender(sender);
    if (parsedSender.length > 2) {
      parsedSender = parsedSender.substring(1);
    }

    if (cmd === "ÎèÑÍ∞ÄÌÜ†") {
      const { Raids } = await LostArkApi.getGuardians();
      return res.send({
        reply: `üëæ Ïù¥Î≤àÏ£º ÎèÑÏ†Ñ Í∞ÄÎîîÏñ∏ ÌÜ†Î≤åÏùÄ\n${Raids.map((r) => r.Name).join(", ")}ÏûÖÎãàÎã§.`,
      });
    }

    if (cmd === "ÎèÑÎπÑÏä§") {
      const abyss = await LostArkApi.getAbyss();
      return res.send({ reply: `üö© Ïù¥Î≤àÏ£º ÎèÑÏ†Ñ Ïñ¥ÎπÑÏä§ ÏßÄÏó≠ÏùÄ\n${abyss[0].AreaName}ÏûÖÎãàÎã§.` });
    }

    if (cmd === "Ïö¥ÏÑ∏") {
      if (timestamp.getDate() !== new Date().getDate()) {
        timestamp = new Date();
        FortuneMap.clear();
      }

      let response = FortuneMap.get(parsedSender);

      if (!response) {
        response = await FortuneApi.getFortune();
        FortuneMap.set(parsedSender, response);
      }

      return res.send({
        reply: response.fortune.format(parsedSender),
        secondReply: response?.msg?.format(parsedSender),
        delayTime: response.delayTime,
      });
    }

    if (cmd === "Ïò§ÎäòÎ™®ÌóòÏÑ¨" || cmd === "Î™®ÌóòÏÑ¨") {
      const calender = await LostArkApi.getCalendar();
      const time = calender[0].StartTimes.find((t) => new Date().getTime() < new Date(t).getTime());

      if (!time) {
        return res.send({ reply: "Ïò§Îäò Î™®ÌóòÏÑ¨ ÏûÖÏû•ÏùÄ ÎÅùÎÇ¨ÏäµÎãàÎã§. ÎÇ¥Ïùº Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî Ï∞°Í∏ã" });
      }

      let message = "üèù Ïò§ÎäòÏùò Î™®ÌóòÏÑ¨Ïù¥ÏóêÏöî.";
      message += `\n`;
      message += `\n [ÏûÖÏû• Í∞ÄÎä• ÏãúÍ∞Ñ] : ${format(new Date(time), "kkÏãú mmÎ∂Ñ")}`;
      message += `\n`;

      calender.forEach((island) => {
        let icon: string;
        let itemName = island.RewardItems[0]?.Name;
        if (itemName) {
          if (itemName === "Ïã§ÎßÅ") {
            icon = "üí≤";
          } else if (itemName.includes("Ïπ¥Îìú Ìå©")) {
            itemName = "Ïπ¥Îìú Ìå©";
            icon = "üÉè";
          } else if (itemName === "Í≥®Îìú") {
            icon = "üí∞";
          } else {
            icon = "‚õµ";
          }
          message += `\n- ${island.ContentsName} (${icon} ${itemName})`;
        }
      });

      message += `\n\n`;

      return res.send({ reply: message });
    }

    if (cmd === "Ïú†Ï†Ä") {
      const userName = args.shift();

      if (!userName) {
        return res.send({ reply: "‚ùå Ïú†Ï†Ä Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî" });
      }

      const { engravings, equipment, gems, profile } = await LostArkApi.getUser(userName);

      if (!profile) {
        return res.send({ reply: "‚ùå Ìï¥Îãπ Ïú†Ï†Ä Ï†ïÎ≥¥Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäîÎç∞Ïöî?" });
      }

      const tooltips = equipment?.map((eq) => {
        const target = JSON.parse(eq.Tooltip).Element_008?.value.Element_000?.contentStr;
        if (target) {
          return [
            parseElilxer(target.Element_000?.contentStr.split("<br>")[0] || ""),
            parseElilxer(target.Element_001?.contentStr.split("<br>")[0] || ""),
          ];
        } else {
          return undefined;
        }
      });

      let message = "";
      message += `@${profile.CharacterName} / ${profile.GuildName}\n`;
      message += `${profile.CharacterClassName} / üíé Lv ${profile.ItemMaxLevel} (${profile.CharacterLevel})\n`;
      message += `\n`;
      message += `‚ö° [ Í∞ÅÏù∏ ] ‚ö°\n`;
      engravings?.Effects.forEach((ef) => {
        message += ` - ${ef.Name}\n`;
      });
      message += `\n`;
      message += `üé≤ [ ÌäπÏÑ± ] üé≤\n`;
      profile.Stats?.sort((a, b) => Number(b.Value) - Number(a.Value));
      profile.Stats?.forEach((stat) => {
        if (stat.Type !== "Ïù∏ÎÇ¥" && stat.Type !== "ÏàôÎ†®" && stat.Type !== "Ï†úÏïï") {
          message += ` - ${stat.Type} : ${Number(stat.Value).toLocaleString()}\n`;
        }
      });
      message += `\n`;
      message += `‚öî [ Ïû•ÎπÑ ] ‚öî\n`;
      equipment?.forEach((item, index) => {
        if (
          item.Type === "Î¨¥Í∏∞" ||
          item.Type === "Ìà¨Íµ¨" ||
          item.Type === "ÏÉÅÏùò" ||
          item.Type === "ÌïòÏùò" ||
          item.Type === "Ïû•Í∞ë" ||
          item.Type === "Ïñ¥Íπ®"
        ) {
          const Elixir = tooltips?.[index];
          message += `${item.Name}`;
          if (Elixir && item.Type !== "Î¨¥Í∏∞") {
            message += `\n ${Elixir[0]}`;
            if (Elixir[1]) {
              message += `, ${Elixir[1]}`;
            }
          }
          message += "\n";
        }
      });
      message += `\n`;
      message += `üíé [ Î≥¥ÏÑù ] üíé\n`;
      gems?.Gems.forEach((gem, index) => {
        message += ` - ${gem.Name.replace(/<[^>]*>?/g, "").replace("Ïùò Î≥¥ÏÑù", "")}`;
        if ((index + 1) % 2 === 0) {
          message += `\n`;
        }
      });
      return res.send({ reply: message });
    }

    if (cmd === "Í±∞ÎûòÏÜå") {
      const keyword = msg.replace("/Í±∞ÎûòÏÜå", "").trim();
      const response = await LostArkApi.searchMarket(keyword);

      let message = "";

      if (response.length === 0) {
        return res.send("Ìï¥Îãπ Í≤ÄÏÉâÏñ¥Ïóê ÎåÄÌïú Í≤∞Í≥ºÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
      }

      response.forEach((item, index) => {
        message += `${index + 1}. ${item.Name} - ${item.Grade}\n`;
        message += `- Ï†ÑÏùº : ${item.YDayAvgPrice.toLocaleString()}Í≥®Îìú, ÏµúÏ†Ä : ${item.CurrentMinPrice.toLocaleString()}Í≥®Îìú`;
        if (index !== response.length - 1) {
          message += "\n\n";
        }
      });

      return res.send({ reply: message });
    }

    if (cmd === "Í≤ΩÎß§Ïû•") {
      const keyword = msg.replace("/Í≤ΩÎß§Ïû•", "").trim();
      const response = await LostArkApi.searchAuction(keyword);

      let message = "";

      if (!response.Items || response.Items.length === 0) {
        return res.send("Ìï¥Îãπ Í≤ÄÏÉâÏñ¥Ïóê ÎåÄÌïú Í≤∞Í≥ºÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
      }

      response.Items.forEach((item, index, array) => {
        if (index < 5) {
          message += `${index + 1}. ${item.Name}\n`;
          message += `- Ï¶âÍµ¨ : ${item.AuctionInfo.BuyPrice?.toLocaleString()}, ÏûÖÏ∞∞ : ${item.AuctionInfo.StartPrice.toLocaleString()}`;
          if (index !== array.length - 1 && index !== 4) {
            message += `\n\n`;
          }
        }
      });
      return res.send({ reply: message });
    }

    if (cmd && (cmd.length >= 2 || MSG_COMMAND_LIST.some((msg) => msg.includes(cmd)))) {
      const message =
        "‚å® ÌòÑÏû¨ ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™ÖÎ†πÏñ¥Îäî" +
        `\n 1. /Ïú†Ï†Ä ÎãâÎÑ§ÏûÑ` +
        "\n - Ïú†Ï†ÄÏ†ïÎ≥¥Î•º Í∞ÄÏßÄÍ≥† ÏòµÎãàÎã§." +
        `\n 2. /Ïö¥ÏÑ∏` +
        "\n - Ïò§Îäò ÎÇòÏùò Í≤åÏûÑ Ïö¥ÏùÑ ÌôïÏù∏Ìï¥ Î≥º Ïàò ÏûàÏñ¥Ïöî." +
        `\n 3. /Î™ÖÎ†πÏñ¥, /?` +
        "\n - Ï†ÑÏ≤¥ Î™ÖÎ†πÏñ¥Î•º ÌôïÏù∏Ìï©ÎãàÎã§." +
        `\n 4. /ÎèÑÎπÑÏä§` +
        "\n - Ïù¥Î≤àÏ£º ÎèÑÏ†Ñ Ïñ¥ÎπÑÏä§ ÎçòÏ†ÑÏùÑ ÌôïÏù∏ Ìï† Ïàò ÏûàÏñ¥Ïöî." +
        `\n 5. /ÎèÑÍ∞ÄÌÜ†` +
        "\n - Ïù¥Î≤àÏ£º ÎèÑÏ†Ñ Í∞ÄÎîîÏñ∏ ÌÜ†Î≤åÏùÑ ÌôïÏù∏ Ìï†Ïàò ÏûàÏñ¥Ïöî." +
        `\n 6. /Í±∞ÎûòÏÜå ÏïÑÏù¥ÌÖúÏù¥Î¶Ñ` +
        "\n - Í±∞ÎûòÏÜåÏóê Îì±Î°ùÎêòÏñ¥ ÏûàÎäî ÏïÑÏù¥ÌÖúÏùò Í∞ÄÍ≤©ÏùÑ ÌôïÏù∏ Ìï† Ïàò ÏûàÏñ¥Ïöî. " +
        "\n ‚Äª ex) /Í±∞ÎûòÏÜå ÏõêÌïú Í∞ÅÏù∏ÏÑú" +
        `\n 7. /Í≤ΩÎß§Ïû• ÏïÑÏù¥ÌÖúÏù¥Î¶Ñ` +
        "\n - Í±∞ÎûòÏÜåÏóê Îì±Î°ùÎêòÏñ¥ ÏûàÎäî ÏïÑÏù¥ÌÖúÏùò Í∞ÄÍ≤©ÏùÑ ÌôïÏù∏ Ìï† Ïàò ÏûàÏñ¥Ïöî. ÌòÑÏû¨Îäî Î≥¥ÏÑùÎßå ÌôïÏù∏ Í∞ÄÎä•Ìï¥Ïöî." +
        "\n ‚Äª ex) /Í±∞ÎûòÏÜå 10Î†àÎ≤® Î©∏Ìôî" +
        `\n 8. ÎîîÏΩî ÎàÑÍµ¨` +
        "\n - ÌòÑÏû¨ ÎîîÏä§ÏΩîÎìúÎ∞©Ïóê Ï†ëÏÜçÏ§ëÏù∏ Í∏∏ÎìúÏõê Î™©Î°ùÏùÑ ÌôïÏù∏ Ìï† Ïàò ÏûàÏñ¥Ïöî." +
        `\n` +
        `\n üìå Ï£ºÏùòÏÇ¨Ìï≠` +
        `\n ÎÑàÎ¨¥ ÏûêÏ£º Ïì∞ÏãúÎ©¥ Ïπ¥Ïπ¥Ïò§ÏóêÏÑú Ï†à Ï´ìÏïÑÎÇºÏàòÎèÑ ÏûàÏñ¥Ïöî. üò™`;

      return res.send({
        reply: message,
      });
    }

    return res.send("success");
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(error);
    return res.send({ status: "error", reply: "ÏóêÎü¨ÎÇ¨Ïñ¥Ïöî „Ö†" + error });
  }
});

export default MessageRouter;
